{"ast":null,"code":"const minimatch = require('minimatch');\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('nodemon:match');\nconst utils = require('../utils');\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n  var cwd = process.cwd();\n\n  // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n    if (not) {\n      rule = rule.slice(1);\n    }\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n    var dir = path.resolve(cwd, rule);\n    try {\n      var stat = fs.statSync(dir);\n      if (stat.isDirectory()) {\n        rule = dir;\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n        rule += '**/*';\n\n        // `!not` ... sorry.\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    }\n\n    // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n    if (rule.slice(-4) !== '**/*' && rule.slice(-1) === '*' && rule.indexOf('*.') === -1) {\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n    return (not ? '!' : '') + rule;\n  });\n  return monitor;\n}\nfunction tryBaseDir(dir) {\n  var stat;\n  if (/[?*\\{\\[]+/.test(dir)) {\n    // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {\n      // console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir);\n      // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) {}\n  }\n  return false;\n}\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n      return 1;\n    }\n    if (r === 0) {\n      return b.length - a.length;\n    }\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n\n      // if it starts with a period, then let's get the relative path\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    }\n\n    // if it starts with a period, then let's get the relative path\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n  debug('rules', rules);\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true\n  };\n\n  // enable case-insensitivity on Windows\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n    var matched = false;\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++;\n\n          // don't repeat the output if a rule is matched\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          }\n\n          // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n          if (rules[i] !== '**' + path.sep + '*.*' && rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n          matched = true;\n          break;\n        } else {\n          // utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n    if (!matched) {\n      ignored++;\n    }\n  });\n  debug('good', good);\n\n  // finally check the good files against the extensions that we're monitoring\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n  var result = good.concat(whitelist);\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length\n  };\n}","map":{"version":3,"names":["minimatch","require","path","fs","debug","utils","module","exports","match","rulesToMonitor","watch","ignore","config","monitor","Array","isArray","length","clone","push","apply","map","rule","cwd","process","not","slice","dir","resolve","stat","statSync","isDirectory","dirs","Error","e","base","tryBaseDir","indexOf","test","dirname","replace","error","isFile","files","ext","rules","sort","a","b","r","split","sep","aIsIgnore","bIsIgnore","s","prefix","substring","good","whitelist","ignored","watched","usedRules","minimatchOpts","dot","isWindows","nocase","forEach","file","matched","i","log","detail","basename","filter","result","concat","toLowerCase","total"],"sources":["C:/Users/789bet/node_modules/nodemon/lib/monitor/match.js"],"sourcesContent":["const minimatch = require('minimatch');\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('nodemon:match');\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd();\n\n  // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n      if (stat.isDirectory()) {\n        rule = dir;\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n        rule += '**/*';\n\n        // `!not` ... sorry.\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    }\n\n    // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n    if (rule.slice(-4) !== '**/*' &&\n      rule.slice(-1) === '*' &&\n      rule.indexOf('*.') === -1) {\n\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n\n    return (not ? '!' : '') + rule;\n  });\n\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n  if (/[?*\\{\\[]+/.test(dir)) { // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {\n      // console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir);\n      // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) { }\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n\n      // if it starts with a period, then let's get the relative path\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    }\n\n    // if it starts with a period, then let's get the relative path\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n\n  debug('rules', rules);\n\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true,\n  };\n\n  // enable case-insensitivity on Windows\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n\n    var matched = false;\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++;\n\n          // don't repeat the output if a rule is matched\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          }\n\n          // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n          if (rules[i] !== '**' + path.sep + '*.*' &&\n            rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n          matched = true;\n          break;\n        } else {\n          // utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n    if (!matched) {\n      ignored++;\n    }\n  });\n\n  debug('good', good)\n\n  // finally check the good files against the extensions that we're monitoring\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}