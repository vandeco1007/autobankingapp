{"ast":null,"code":"var debug = require('debug')('nodemon:run');\nconst statSync = require('fs').statSync;\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar childProcess = require('child_process');\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar execSync = childProcess.execSync;\nvar fork = childProcess.fork;\nvar watch = require('./watch').watch;\nvar config = require('../config');\nvar child = null; // the actual child process we spawn\nvar killedAfterChange = false;\nvar noop = () => {};\nvar restart = null;\nvar psTree = require('pstree.remy');\nvar path = require('path');\nvar signals = require('./signals');\nconst osRelease = parseInt(require('os').release().split('.')[0], 10);\nfunction run(options) {\n  var cmd = config.command.raw;\n  // moved up\n  // we need restart function below in the global scope for run.kill\n  /*jshint validthis:true*/\n  restart = run.bind(this, options);\n  run.restart = restart;\n\n  // binding options with instance of run\n  // so that we can use it in run.kill\n  run.options = options;\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  } else {\n    // should just watch file if command is not to be run\n    // had another alternate approach\n    // to stop process being forked/spawned in the below code\n    // but this approach does early exit and makes code cleaner\n    debug('start watch on: %s', config.options.watch);\n    if (config.options.watch !== false) {\n      watch();\n      return;\n    }\n  }\n  config.lastStarted = Date.now();\n  var stdio = ['pipe', 'pipe', 'pipe'];\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n  var sh = 'sh';\n  var shFlag = '-c';\n  const binPath = process.cwd() + '/node_modules/.bin';\n  const spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + path.delimiter + process.env.PATH\n    }),\n    stdio: stdio\n  };\n  var executable = cmd.executable;\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable.split(' ').map((e, i) => {\n        if (i === 0) {\n          return path.normalize(e);\n        }\n        return e;\n      }).join(' ');\n    }\n    // taken from npm's cli: https://git.io/vNFD4\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n  const firstArg = cmd.args[0] || '';\n  var inBinPath = false;\n  try {\n    inBinPath = statSync(`${binPath}/${executable}`).isFile();\n  } catch (e) {}\n\n  // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');\n\n  // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n  const shouldFork = !config.options.spawn && !inBinPath && !(firstArg.indexOf('-') === 0) &&\n  // don't fork if there's a node exec arg\n  firstArg !== 'inspect' &&\n  // don't fork it's `inspect` debugger\n  executable === 'node' &&\n  // only fork if node\n  utils.version.major > 4; // only fork if node version > 4\n\n  if (shouldFork) {\n    // this assumes the first argument is the script and slices it out, since\n    // we're forking\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args);\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args);\n  }\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      }\n    };\n\n    // now work out what to bind to...\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n  bus.emit('start');\n  utils.log.detail('child pid: ' + child.pid);\n  child.on('error', function (error) {\n    bus.emit('error', error);\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n    if (code === 127) {\n      utils.log.error('failed to start process, \"' + cmd.executable + '\" exec not found');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // In case we killed the app ourselves, set the signal thusly\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    }\n    // this is nasty, but it gives it windows support\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal);\n\n      // exit the monitor, but do it gracefully\n      if (signal === config.signal) {\n        return restart();\n      }\n      if (code === 0) {\n        // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail('app crashed - waiting for file changes before' + ' starting...');\n        child = null;\n      }\n    }\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  });\n\n  // moved the run.kill outside to handle both the cases\n  // intial start\n  // no start\n\n  // connect stdin to the child process (options.stdin is on by default)\n  if (options.stdin) {\n    process.stdin.resume();\n    // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n    if (hasStdio) {\n      child.stdin.on('error', () => {});\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error('running an unsupported version of node ' + process.version);\n        utils.log.error('nodemon may not work as expected - ' + 'please consider upgrading to LTS');\n      }\n    }\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) {\n        // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n  debug('start watch on: %s', config.options.watch);\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\nfunction waitForSubProcesses(pid, callback) {\n  debug('checking ps tree for pids of ' + pid);\n  psTree(pid, (err, pids) => {\n    if (!pids.length) {\n      return callback();\n    }\n    utils.log.status(`still waiting for ${pids.length} sub-process${pids.length > 2 ? 'es' : ''} to finish...`);\n    setTimeout(() => waitForSubProcesses(pid, callback), 1000);\n  });\n}\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = noop;\n  }\n  if (utils.isWindows) {\n    const taskKill = () => {\n      try {\n        exec('taskkill /pid ' + child.pid + ' /T /F');\n      } catch (e) {\n        utils.log.error('Could not shutdown sub process cleanly');\n      }\n    };\n\n    // We are handling a 'SIGKILL' , 'SIGUSR2' and 'SIGUSR1' POSIX signal under Windows the\n    // same way it is handled on a UNIX system: We are performing\n    // a hard shutdown without waiting for the process to clean-up.\n    if (signal === 'SIGKILL' || osRelease < 10 || signal === 'SIGUSR2' || signal === \"SIGUSR1\") {\n      debug('terminating process group by force: %s', child.pid);\n\n      // We are using the taskkill utility to terminate the whole\n      // process group ('/t') of the child ('/pid') by force ('/f').\n      // We need to end all sub processes, because the 'child'\n      // process in this context is actually a cmd.exe wrapper.\n      taskKill();\n      callback();\n      return;\n    }\n    try {\n      // We are using the Windows Management Instrumentation Command-line\n      // (wmic.exe) to resolve the sub-child process identifier, because the\n      // 'child' process in this context is actually a cmd.exe wrapper.\n      // We want to send the termination signal directly to the node process.\n      // The '2> nul' silences the no process found error message.\n      const resultBuffer = execSync(`wmic process where (ParentProcessId=${child.pid}) get ProcessId 2> nul`);\n      const result = resultBuffer.toString().match(/^[0-9]+/m);\n\n      // If there is no sub-child process we fall back to the child process.\n      const processId = Array.isArray(result) ? result[0] : child.pid;\n      debug('sending kill signal SIGINT to process: %s', processId);\n\n      // We are using the standalone 'windows-kill' executable to send the\n      // standard POSIX signal 'SIGINT' to the node process. This fixes #1720.\n      const windowsKill = path.normalize(`${__dirname}/../../bin/windows-kill.exe`);\n\n      // We have to detach the 'windows-kill' execution completely from this\n      // process group to avoid terminating the nodemon process itself.\n      // See: https://github.com/alirdn/windows-kill#how-it-works--limitations\n      //\n      // Therefore we are using 'start' to create a new cmd.exe context.\n      // The '/min' option hides the new terminal window and the '/wait'\n      // option lets the process wait for the command to finish.\n\n      execSync(`start \"windows-kill\" /min /wait \"${windowsKill}\" -SIGINT ${processId}`);\n    } catch (e) {\n      taskKill();\n    }\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    let sig = signal.replace('SIG', '');\n    psTree(child.pid, function (err, pids) {\n      // if ps isn't native to the OS, then we need to send the numeric value\n      // for the signal during the kill, `signals` is a lookup table for that.\n      if (!psTree.hasPS) {\n        sig = signals[signal];\n      }\n\n      // the sub processes need to be killed from smallest to largest\n      debug('sending kill signal to ' + pids.join(', '));\n      child.kill(signal);\n      pids.sort().forEach(pid => exec(`kill -${sig} ${pid}`, noop));\n      waitForSubProcesses(child.pid, () => {\n        // finally kill the main user process\n        exec(`kill -${sig} ${child.pid}`, callback);\n      });\n    });\n  }\n}\nrun.kill = function (noRestart, callback) {\n  // I hate code like this :(  - Remy (author of said code)\n  if (typeof noRestart === 'function') {\n    callback = noRestart;\n    noRestart = false;\n  }\n  if (!callback) {\n    callback = noop;\n  }\n  if (child !== null) {\n    // if the stdin piping is on, we need to unpipe, but also close stdin on\n    // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n    if (run.options.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    // For the on('exit', ...) handler above the following looks like a\n    // crash, so we set the killedAfterChange flag if a restart is planned\n    if (!noRestart) {\n      killedAfterChange = true;\n    }\n\n    /* Now kill the entire subtree of processes belonging to nodemon */\n    var oldPid = child.pid;\n    if (child) {\n      kill(child, config.signal, function () {\n        // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n        // though I'm unsure why. it seems like more data is streamed in to\n        // stdin after we close.\n        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {\n          child.stdin.end();\n        }\n        callback();\n      });\n    }\n  } else if (!noRestart) {\n    // if there's no child, then we need to manually start the process\n    // this is because as there was no child, the child.on('exit') event\n    // handler doesn't exist which would normally trigger the restart.\n    bus.once('start', callback);\n    run.restart();\n  } else {\n    callback();\n  }\n};\nrun.restart = noop;\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  }\n\n  // remove event listener\n  var exitTimer = null;\n  var exit = function () {\n    clearTimeout(exitTimer);\n    exit = noop; // null out in case of race condition\n    child = null;\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  };\n\n  // if we're not running already, don't bother with trying to kill\n  if (config.run === false) {\n    return exit();\n  }\n\n  // immediately try to stop any polling\n  config.run = false;\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', exit);\n    kill(child, 'SIGINT');\n  } else {\n    exit();\n  }\n});\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n});\n\n// remove the child file on exit\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n  if (child) {\n    child.kill();\n  }\n});\n\n// because windows borks when listening for the SIG* events\nif (!utils.isWindows) {\n  bus.once('boot', () => {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', () => bus.emit('quit', 130));\n    process.once('SIGTERM', () => {\n      bus.emit('quit', 143);\n      if (child) {\n        child.kill('SIGTERM');\n      }\n    });\n  });\n}\nmodule.exports = run;","map":{"version":3,"names":["debug","require","statSync","utils","bus","childProcess","spawn","exec","execSync","fork","watch","config","child","killedAfterChange","noop","restart","psTree","path","signals","osRelease","parseInt","release","split","run","options","cmd","command","raw","bind","runCmd","runOnChangeOnly","lastStarted","log","status","string","Date","now","stdio","stdout","process","stderr","stdin","sh","shFlag","binPath","cwd","spawnOptions","env","Object","assign","execOptions","PATH","delimiter","executable","isWindows","indexOf","map","e","i","normalize","join","comspec","windowsVerbatimArguments","args","stringify","spawnArgs","firstArg","inBinPath","isFile","hasStdio","satisfies","shouldFork","version","major","forkArgs","slice","merge","push","script","silent","detail","apply","required","emit","data","on","message","sendHandle","pid","error","code","exit","signal","unpipe","exitcrash","fail","restartable","resume","pipe","once","waitForSubProcesses","callback","err","pids","length","setTimeout","kill","taskKill","resultBuffer","result","toString","match","processId","Array","isArray","windowsKill","__dirname","sig","replace","hasPS","sort","forEach","noRestart","oldPid","end","onQuit","undefined","exitTimer","clearTimeout","listeners","listener","removeAllListeners","module","exports"],"sources":["C:/Users/789bet/node_modules/nodemon/lib/monitor/run.js"],"sourcesContent":["var debug = require('debug')('nodemon:run');\nconst statSync = require('fs').statSync;\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar childProcess = require('child_process');\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar execSync = childProcess.execSync;\nvar fork = childProcess.fork;\nvar watch = require('./watch').watch;\nvar config = require('../config');\nvar child = null; // the actual child process we spawn\nvar killedAfterChange = false;\nvar noop = () => {};\nvar restart = null;\nvar psTree = require('pstree.remy');\nvar path = require('path');\nvar signals = require('./signals');\nconst osRelease = parseInt(require('os').release().split('.')[0], 10);\n\nfunction run(options) {\n  var cmd = config.command.raw;\n  // moved up\n  // we need restart function below in the global scope for run.kill\n  /*jshint validthis:true*/\n  restart = run.bind(this, options);\n  run.restart = restart;\n\n  // binding options with instance of run\n  // so that we can use it in run.kill\n  run.options = options;\n\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  } else {\n    // should just watch file if command is not to be run\n    // had another alternate approach\n    // to stop process being forked/spawned in the below code\n    // but this approach does early exit and makes code cleaner\n    debug('start watch on: %s', config.options.watch);\n    if (config.options.watch !== false) {\n      watch();\n      return;\n    }\n  }\n\n  config.lastStarted = Date.now();\n\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n\n  const binPath = process.cwd() + '/node_modules/.bin';\n\n  const spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + path.delimiter + process.env.PATH,\n    }),\n    stdio: stdio,\n  };\n\n  var executable = cmd.executable;\n\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable\n        .split(' ')\n        .map((e, i) => {\n          if (i === 0) {\n            return path.normalize(e);\n          }\n          return e;\n        })\n        .join(' ');\n    }\n    // taken from npm's cli: https://git.io/vNFD4\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n\n  const firstArg = cmd.args[0] || '';\n\n  var inBinPath = false;\n  try {\n    inBinPath = statSync(`${binPath}/${executable}`).isFile();\n  } catch (e) {}\n\n  // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');\n\n  // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n  const shouldFork =\n    !config.options.spawn &&\n    !inBinPath &&\n    !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg\n    firstArg !== 'inspect' && // don't fork it's `inspect` debugger\n    executable === 'node' && // only fork if node\n    utils.version.major > 4; // only fork if node version > 4\n\n  if (shouldFork) {\n    // this assumes the first argument is the script and slices it out, since\n    // we're forking\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio,\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args);\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args);\n  }\n\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      },\n    };\n\n    // now work out what to bind to...\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n\n  bus.emit('start');\n\n  utils.log.detail('child pid: ' + child.pid);\n\n  child.on('error', function (error) {\n    bus.emit('error', error);\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    if (code === 127) {\n      utils.log.error(\n        'failed to start process, \"' + cmd.executable + '\" exec not found'\n      );\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // In case we killed the app ourselves, set the signal thusly\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    }\n    // this is nasty, but it gives it windows support\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal);\n\n      // exit the monitor, but do it gracefully\n      if (signal === config.signal) {\n        return restart();\n      }\n\n      if (code === 0) {\n        // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail(\n          'app crashed - waiting for file changes before' + ' starting...'\n        );\n        child = null;\n      }\n    }\n\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  });\n\n  // moved the run.kill outside to handle both the cases\n  // intial start\n  // no start\n\n  // connect stdin to the child process (options.stdin is on by default)\n  if (options.stdin) {\n    process.stdin.resume();\n    // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n    if (hasStdio) {\n      child.stdin.on('error', () => {});\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error(\n          'running an unsupported version of node ' + process.version\n        );\n        utils.log.error(\n          'nodemon may not work as expected - ' +\n            'please consider upgrading to LTS'\n        );\n      }\n    }\n\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) {\n        // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n\n  debug('start watch on: %s', config.options.watch);\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\n\nfunction waitForSubProcesses(pid, callback) {\n  debug('checking ps tree for pids of ' + pid);\n  psTree(pid, (err, pids) => {\n    if (!pids.length) {\n      return callback();\n    }\n\n    utils.log.status(\n      `still waiting for ${pids.length} sub-process${\n        pids.length > 2 ? 'es' : ''\n      } to finish...`\n    );\n    setTimeout(() => waitForSubProcesses(pid, callback), 1000);\n  });\n}\n\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (utils.isWindows) {\n    const taskKill = () => {\n      try {\n        exec('taskkill /pid ' + child.pid + ' /T /F');\n      } catch (e) {\n        utils.log.error('Could not shutdown sub process cleanly');\n      }\n    };\n\n    // We are handling a 'SIGKILL' , 'SIGUSR2' and 'SIGUSR1' POSIX signal under Windows the\n    // same way it is handled on a UNIX system: We are performing\n    // a hard shutdown without waiting for the process to clean-up.\n    if (signal === 'SIGKILL' || osRelease < 10 || signal === 'SIGUSR2' || signal===\"SIGUSR1\" ) {\n      debug('terminating process group by force: %s', child.pid);\n\n      // We are using the taskkill utility to terminate the whole\n      // process group ('/t') of the child ('/pid') by force ('/f').\n      // We need to end all sub processes, because the 'child'\n      // process in this context is actually a cmd.exe wrapper.\n      taskKill();\n      callback();\n      return;\n    }\n\n    try {\n      // We are using the Windows Management Instrumentation Command-line\n      // (wmic.exe) to resolve the sub-child process identifier, because the\n      // 'child' process in this context is actually a cmd.exe wrapper.\n      // We want to send the termination signal directly to the node process.\n      // The '2> nul' silences the no process found error message.\n      const resultBuffer = execSync(\n        `wmic process where (ParentProcessId=${child.pid}) get ProcessId 2> nul`\n      );\n      const result = resultBuffer.toString().match(/^[0-9]+/m);\n\n      // If there is no sub-child process we fall back to the child process.\n      const processId = Array.isArray(result) ? result[0] : child.pid;\n\n      debug('sending kill signal SIGINT to process: %s', processId);\n\n      // We are using the standalone 'windows-kill' executable to send the\n      // standard POSIX signal 'SIGINT' to the node process. This fixes #1720.\n      const windowsKill = path.normalize(\n        `${__dirname}/../../bin/windows-kill.exe`\n      );\n\n      // We have to detach the 'windows-kill' execution completely from this\n      // process group to avoid terminating the nodemon process itself.\n      // See: https://github.com/alirdn/windows-kill#how-it-works--limitations\n      //\n      // Therefore we are using 'start' to create a new cmd.exe context.\n      // The '/min' option hides the new terminal window and the '/wait'\n      // option lets the process wait for the command to finish.\n\n      execSync(\n        `start \"windows-kill\" /min /wait \"${windowsKill}\" -SIGINT ${processId}`\n      );\n    } catch (e) {\n      taskKill();\n    }\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    let sig = signal.replace('SIG', '');\n\n    psTree(child.pid, function (err, pids) {\n      // if ps isn't native to the OS, then we need to send the numeric value\n      // for the signal during the kill, `signals` is a lookup table for that.\n      if (!psTree.hasPS) {\n        sig = signals[signal];\n      }\n\n      // the sub processes need to be killed from smallest to largest\n      debug('sending kill signal to ' + pids.join(', '));\n\n      child.kill(signal);\n\n      pids.sort().forEach((pid) => exec(`kill -${sig} ${pid}`, noop));\n\n      waitForSubProcesses(child.pid, () => {\n        // finally kill the main user process\n        exec(`kill -${sig} ${child.pid}`, callback);\n      });\n    });\n  }\n}\n\nrun.kill = function (noRestart, callback) {\n  // I hate code like this :(  - Remy (author of said code)\n  if (typeof noRestart === 'function') {\n    callback = noRestart;\n    noRestart = false;\n  }\n\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (child !== null) {\n    // if the stdin piping is on, we need to unpipe, but also close stdin on\n    // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n    if (run.options.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    // For the on('exit', ...) handler above the following looks like a\n    // crash, so we set the killedAfterChange flag if a restart is planned\n    if (!noRestart) {\n      killedAfterChange = true;\n    }\n\n    /* Now kill the entire subtree of processes belonging to nodemon */\n    var oldPid = child.pid;\n    if (child) {\n      kill(child, config.signal, function () {\n        // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n        // though I'm unsure why. it seems like more data is streamed in to\n        // stdin after we close.\n        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {\n          child.stdin.end();\n        }\n        callback();\n      });\n    }\n  } else if (!noRestart) {\n    // if there's no child, then we need to manually start the process\n    // this is because as there was no child, the child.on('exit') event\n    // handler doesn't exist which would normally trigger the restart.\n    bus.once('start', callback);\n    run.restart();\n  } else {\n    callback();\n  }\n};\n\nrun.restart = noop;\n\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  }\n\n  // remove event listener\n  var exitTimer = null;\n  var exit = function () {\n    clearTimeout(exitTimer);\n    exit = noop; // null out in case of race condition\n    child = null;\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  };\n\n  // if we're not running already, don't bother with trying to kill\n  if (config.run === false) {\n    return exit();\n  }\n\n  // immediately try to stop any polling\n  config.run = false;\n\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', exit);\n\n    kill(child, 'SIGINT');\n  } else {\n    exit();\n  }\n});\n\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n});\n\n// remove the child file on exit\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n  if (child) {\n    child.kill();\n  }\n});\n\n// because windows borks when listening for the SIG* events\nif (!utils.isWindows) {\n  bus.once('boot', () => {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', () => bus.emit('quit', 130));\n    process.once('SIGTERM', () => {\n      bus.emit('quit', 143);\n      if (child) {\n        child.kill('SIGTERM');\n      }\n    });\n  });\n}\n\nmodule.exports = run;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}