{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({\n      ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get hello() {\n    return this[kHello];\n  }\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n  get isMonitoringConnection() {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n  get serviceId() {\n    var _a;\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this[kStream];\n  }\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n  onError(error) {\n    if (this.closed) {\n      return;\n    }\n    this[kStream].destroy(error);\n    this.closed = true;\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    const message = `connection ${this.id} to ${this.address} closed`;\n    for (const op of this[kQueue].values()) {\n      op.cb(new error_1.MongoNetworkError(message));\n    }\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n    this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n      this[kStream].destroy();\n      this.closed = true;\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      for (const op of this[kQueue].values()) {\n        op.cb(new error_1.MongoNetworkTimeoutError(message, {\n          beforeHandshake\n        }));\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n    const callback = operationDescription.cb;\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  }\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n      if (err) {\n        return callback(err);\n      }\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = (0, utils_1.maxWireVersion)(this);\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, {\n        ...(0, bson_1.pluckBSONSerializeOptions)(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      getMoreCmd.comment = options.comment;\n    }\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n    if ((0, utils_1.maxWireVersion)(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n      return;\n    }\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback(\n        // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n      callback(undefined, response.documents[0]);\n    });\n  }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"mappings":"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","names":["kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kFullResult","kDelayedTimeoutId","Connection","mongo_types_1","constructor","stream","options","id","address","streamIdentifier","socketTimeoutMS","monitorCommands","serverApi","closed","destroyed","stream_description_1","generation","Map","message_stream_1","maxBsonMessageSize","hello","on","message","onMessage","error","onError","onClose","onTimeout","pipe","description","response","receiveResponse","Object","freeze","isMonitoringConnection","value","serviceId","loadBalanced","idleTime","clusterTime","markAvailable","destroy","op","values","cb","clear","emit","CLOSE","error_1","beforeHandshake","unref","delayedTimeoutId","clearTimeout","operationDescription","get","responseTo","callback","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","err","documents","document","session","$clusterTime","CLUSTER_TIME_RECEIVED","command","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","force","removeAllListeners","PINNED","UNPINNED","assign","end","ns","cmd","utils_1","readPreference","shouldUseOpMsg","supportsOpMsg","finalCmd","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","commands_1","write","getMore","cursorId","wireVersion","getMoreOp","toString","batchSize","queryOptions","cursor","nextBatch","getMoreCmd","collection","Math","abs","maxAwaitTimeMS","maxTimeMS","comment","returnFieldSelector","documentsReturnedIn","killCursors","cursorIds","Array","isArray","noResponse","cursors","cursorNotFound","length","exports","constants_1","CryptoConnection","autoEncrypter","serverWireVersion","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","COMMAND_STARTED","command_monitoring_events_1","reply","COMMAND_FAILED","COMMAND_SUCCEEDED","writeCommand","e"],"sources":["C:\\Users\\789bet\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { setTimeout } from 'timers';\n\nimport { BSONSerializeOptions, Document, Long, ObjectId, pluckBSONSerializeOptions } from '../bson';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  MESSAGE,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport type { AutoEncrypter } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport { applySession, ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  calculateDurationInMs,\n  Callback,\n  ClientMetadata,\n  HostAddress,\n  maxWireVersion,\n  MongoDBNamespace,\n  now,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  BinMsg,\n  GetMore,\n  KillCursor,\n  Msg,\n  Query,\n  Response,\n  WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport { MessageStream, OperationDescription } from './message_stream';\nimport { StreamDescription, StreamDescriptionOptions } from './stream_description';\nimport { applyCommonQueryOptions, getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n\n/** @internal */\nexport interface QueryOptions extends BSONSerializeOptions {\n  readPreference: ReadPreference;\n  documentsReturnedIn?: string;\n  batchSize?: number;\n  limit?: number;\n  skip?: number;\n  projection?: Document;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @deprecated use `noCursorTimeout` instead */\n  timeout?: boolean;\n  partial?: boolean;\n  oplogReplay?: boolean;\n}\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  command?: boolean;\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  raw?: boolean;\n  monitoring?: boolean;\n  [kFullResult]?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n}\n\n/** @internal */\nexport interface GetMoreOptions extends CommandOptions {\n  batchSize?: number;\n  maxTimeMS?: number;\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  // Settings\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  keepAlive?: boolean;\n  keepAliveInitialDelay?: number;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n\n  metadata: ClientMetadata;\n}\n\n/** @public */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  closed: boolean;\n  destroyed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n\n  /**@internal */\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kHello]: Document | null;\n  /** @internal */\n  [kClusterTime]: Document | null;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n\n    this[kDelayedTimeoutId] = null;\n\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document | null {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document | null) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value: boolean) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n\n  get isMonitoringConnection(): boolean {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document | null {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  onError(error: Error) {\n    if (this.closed) {\n      return;\n    }\n\n    this[kStream].destroy(error);\n\n    this.closed = true;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const message = `connection ${this.id} to ${this.address} closed`;\n    for (const op of this[kQueue].values()) {\n      op.cb(new MongoNetworkError(message));\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      this[kStream].destroy();\n\n      this.closed = true;\n\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      for (const op of this[kQueue].values()) {\n        op.cb(new MongoNetworkTimeoutError(message, { beforeHandshake }));\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message: BinMsg | Response) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  }\n\n  destroy(options?: DestroyOptions, callback?: Callback): void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = { force: false };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    if (!(ns instanceof MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, finalCmd, options as CommandOptions);\n      if (err) {\n        return callback(err);\n      }\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg\n      ? new Msg(cmdNs, finalCmd, commandOptions)\n      : new Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  getMore(\n    ns: MongoDBNamespace,\n    cursorId: Long,\n    options: GetMoreOptions,\n    callback: Callback<Document>\n  ): void {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = maxWireVersion(this);\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n      const queryOptions = applyCommonQueryOptions(\n        {},\n        Object.assign(options, { ...pluckBSONSerializeOptions(options) })\n      );\n\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n      });\n\n      return;\n    }\n\n    const getMoreCmd: Document = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      getMoreCmd.comment = options.comment;\n    }\n\n    const commandOptions = Object.assign(\n      {\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      },\n      options\n    );\n\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  killCursors(\n    ns: MongoDBNamespace,\n    cursorIds: Long[],\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if (maxWireVersion(this) < 4) {\n      try {\n        write(\n          this,\n          new KillCursor(ns.toString(), cursorIds),\n          { noResponse: true, ...options },\n          callback\n        );\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(\n      ns,\n      { killCursors: ns.collection, cursors: cursorIds },\n      { [kFullResult]: true, ...options },\n      (err, response) => {\n        if (err || !response) return callback(err);\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback(\n            // TODO(NODE-3483)\n            new MongoRuntimeError(\n              `invalid killCursors result returned for cursor id ${cursorIds[0]}`\n            )\n          );\n        }\n\n        callback(undefined, response.documents[0]);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  override command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\n      );\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}