{"ast":null,"code":"const path = require('path');\nconst fs = require('fs');\nconst existsSync = fs.existsSync;\nconst utils = require('../utils');\nmodule.exports = exec;\nmodule.exports.expandScript = expandScript;\n\n/**\n * Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found\n */\nfunction execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return {\n        exec: null,\n        script: pkg.main\n      };\n    }\n    if (pkg.scripts && pkg.scripts.start) {\n      return {\n        exec: pkg.scripts.start\n      };\n    }\n  } catch (e) {}\n  return null;\n}\nfunction replace(map, str) {\n  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');\n  return str.replace(re, function (all, m) {\n    return map[m] || all || '';\n  });\n}\nfunction expandScript(script, ext) {\n  if (!ext) {\n    ext = '.js';\n  }\n  if (script.indexOf(ext) !== -1) {\n    return script;\n  }\n  if (existsSync(path.resolve(script))) {\n    return script;\n  }\n  if (existsSync(path.resolve(script + ext))) {\n    return script + ext;\n  }\n  return script;\n}\n\n/**\n * Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions\n */\nfunction exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {};\n  }\n  var options = utils.clone(nodemonOptions || {});\n  var script;\n\n  // if there's no script passed, try to get it from the first argument\n  if (!options.script && (options.args || []).length) {\n    script = expandScript(options.args[0], options.ext && '.' + (options.ext || 'js').split(',')[0]);\n\n    // if the script was found, shift it off our args\n    if (script !== options.args[0]) {\n      options.script = script;\n      options.args.shift();\n    }\n  }\n\n  // if there's no exec found yet, then try to read it from the local\n  // package.json this logic used to sit in the cli/parse, but actually the cli\n  // should be parsed first, then the user options (via nodemon.json) then\n  // finally default down to pot shots at the directory via package.json\n  if (!options.exec && !options.script) {\n    var found = execFromPackage();\n    if (found !== null) {\n      if (found.exec) {\n        options.exec = found.exec;\n      }\n      if (!options.script) {\n        options.script = found.script;\n      }\n      if (Array.isArray(options.args) && options.scriptPosition === null) {\n        options.scriptPosition = options.args.length;\n      }\n    }\n  }\n\n  // var options = utils.clone(nodemonOptions || {});\n  script = path.basename(options.script || '');\n  var scriptExt = path.extname(script).slice(1);\n  var extension = options.ext;\n  if (extension === undefined) {\n    var isJS = scriptExt === 'js' || scriptExt === 'mjs';\n    extension = isJS || !scriptExt ? 'js,mjs' : scriptExt;\n    extension += ',json'; // Always watch JSON files\n  }\n\n  var execDefined = !!options.exec;\n\n  // allows the user to simplify cli usage:\n  // https://github.com/remy/nodemon/issues/195\n  // but always give preference to the user defined argument\n  if (!options.exec && execMap[scriptExt] !== undefined) {\n    options.exec = execMap[scriptExt];\n    execDefined = true;\n  }\n  options.execArgs = nodemonOptions.execArgs || [];\n  if (Array.isArray(options.exec)) {\n    options.execArgs = options.exec;\n    options.exec = options.execArgs.shift();\n  }\n  if (options.exec === undefined) {\n    options.exec = 'node';\n  } else {\n    // allow variable substitution for {{filename}} and {{pwd}}\n    var substitution = replace.bind(null, {\n      filename: options.script,\n      pwd: process.cwd()\n    });\n    var newExec = substitution(options.exec);\n    if (newExec !== options.exec && options.exec.indexOf('{{filename}}') !== -1) {\n      options.script = null;\n    }\n    options.exec = newExec;\n    var newExecArgs = options.execArgs.map(substitution);\n    if (newExecArgs.join('') !== options.execArgs.join('')) {\n      options.execArgs = newExecArgs;\n      delete options.script;\n    }\n  }\n  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {\n    options.execArgs = options.execArgs.concat(options.nodeArgs);\n  }\n\n  // note: indexOf('coffee') handles both .coffee and .litcoffee\n  if (!execDefined && options.exec === 'node' && scriptExt.indexOf('coffee') !== -1) {\n    options.exec = 'coffee';\n\n    // we need to get execArgs set before the script\n    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an\n    // execArg, while my-flag is a script arg\n    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);\n    options.execArgs = options.execArgs.concat(leadingArgs);\n    options.scriptPosition = 0;\n    if (options.execArgs.length > 0) {\n      // because this is the coffee executable, we need to combine the exec args\n      // into a single argument after the nodejs flag\n      options.execArgs = ['--nodejs', options.execArgs.join(' ')];\n    }\n  }\n  if (options.exec === 'coffee') {\n    // don't override user specified extension tracking\n    if (options.ext === undefined) {\n      if (extension) {\n        extension += ',';\n      }\n      extension += 'coffee,litcoffee';\n    }\n\n    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n    if (utils.isWindows) {\n      options.exec += '.cmd';\n    }\n  }\n\n  // allow users to make a mistake on the extension to monitor\n  // converts .js, pug => js,pug\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against\n  // the file system :(\n  extension = (extension.match(/[^,*\\s]+/g) || []).map(ext => ext.replace(/^\\./, '')).join(',');\n  options.ext = extension;\n  if (options.script) {\n    options.script = expandScript(options.script, extension && '.' + extension.split(',')[0]);\n  }\n  options.env = {};\n  // make sure it's an object (and since we don't have )\n  if ({}.toString.apply(nodemonOptions.env) === '[object Object]') {\n    options.env = utils.clone(nodemonOptions.env);\n  } else if (nodemonOptions.env !== undefined) {\n    throw new Error('nodemon env values must be an object: { PORT: 8000 }');\n  }\n  return options;\n}","map":{"version":3,"names":["path","require","fs","existsSync","utils","module","exports","exec","expandScript","execFromPackage","pkg","join","process","cwd","main","undefined","script","scripts","start","e","replace","map","str","re","RegExp","Object","keys","all","m","ext","indexOf","resolve","nodemonOptions","execMap","options","clone","args","length","split","shift","found","Array","isArray","scriptPosition","basename","scriptExt","extname","slice","extension","isJS","execDefined","execArgs","substitution","bind","filename","pwd","newExec","newExecArgs","nodeArgs","concat","leadingArgs","splice","isWindows","match","env","toString","apply","Error"],"sources":["C:/Users/789bet/node_modules/nodemon/lib/config/exec.js"],"sourcesContent":["const path = require('path');\nconst fs = require('fs');\nconst existsSync = fs.existsSync;\nconst utils = require('../utils');\n\nmodule.exports = exec;\nmodule.exports.expandScript = expandScript;\n\n/**\n * Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found\n */\nfunction execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return { exec: null, script: pkg.main };\n    }\n\n    if (pkg.scripts && pkg.scripts.start) {\n      return { exec: pkg.scripts.start };\n    }\n  } catch (e) { }\n\n  return null;\n}\n\nfunction replace(map, str) {\n  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');\n  return str.replace(re, function (all, m) {\n    return map[m] || all || '';\n  });\n}\n\nfunction expandScript(script, ext) {\n  if (!ext) {\n    ext = '.js';\n  }\n  if (script.indexOf(ext) !== -1) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script))) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script + ext))) {\n    return script + ext;\n  }\n\n  return script;\n}\n\n/**\n * Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions\n */\nfunction exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {};\n  }\n\n  var options = utils.clone(nodemonOptions || {});\n  var script;\n\n  // if there's no script passed, try to get it from the first argument\n  if (!options.script && (options.args || []).length) {\n    script = expandScript(options.args[0],\n      options.ext && ('.' + (options.ext || 'js').split(',')[0]));\n\n    // if the script was found, shift it off our args\n    if (script !== options.args[0]) {\n      options.script = script;\n      options.args.shift();\n    }\n  }\n\n  // if there's no exec found yet, then try to read it from the local\n  // package.json this logic used to sit in the cli/parse, but actually the cli\n  // should be parsed first, then the user options (via nodemon.json) then\n  // finally default down to pot shots at the directory via package.json\n  if (!options.exec && !options.script) {\n    var found = execFromPackage();\n    if (found !== null) {\n      if (found.exec) {\n        options.exec = found.exec;\n      }\n      if (!options.script) {\n        options.script = found.script;\n      }\n      if (Array.isArray(options.args) &&\n        options.scriptPosition === null) {\n        options.scriptPosition = options.args.length;\n      }\n    }\n  }\n\n  // var options = utils.clone(nodemonOptions || {});\n  script = path.basename(options.script || '');\n\n  var scriptExt = path.extname(script).slice(1);\n\n  var extension = options.ext;\n  if (extension === undefined) {\n    var isJS = scriptExt === 'js' || scriptExt === 'mjs';\n    extension = (isJS || !scriptExt) ? 'js,mjs' : scriptExt;\n    extension += ',json'; // Always watch JSON files\n  }\n\n  var execDefined = !!options.exec;\n\n  // allows the user to simplify cli usage:\n  // https://github.com/remy/nodemon/issues/195\n  // but always give preference to the user defined argument\n  if (!options.exec && execMap[scriptExt] !== undefined) {\n    options.exec = execMap[scriptExt];\n    execDefined = true;\n  }\n\n  options.execArgs = nodemonOptions.execArgs || [];\n\n  if (Array.isArray(options.exec)) {\n    options.execArgs = options.exec;\n    options.exec = options.execArgs.shift();\n  }\n\n  if (options.exec === undefined) {\n    options.exec = 'node';\n  } else {\n    // allow variable substitution for {{filename}} and {{pwd}}\n    var substitution = replace.bind(null, {\n      filename: options.script,\n      pwd: process.cwd(),\n    });\n\n    var newExec = substitution(options.exec);\n    if (newExec !== options.exec &&\n      options.exec.indexOf('{{filename}}') !== -1) {\n      options.script = null;\n    }\n    options.exec = newExec;\n\n    var newExecArgs = options.execArgs.map(substitution);\n    if (newExecArgs.join('') !== options.execArgs.join('')) {\n      options.execArgs = newExecArgs;\n      delete options.script;\n    }\n  }\n\n\n  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {\n    options.execArgs = options.execArgs.concat(options.nodeArgs);\n  }\n\n  // note: indexOf('coffee') handles both .coffee and .litcoffee\n  if (!execDefined && options.exec === 'node' &&\n    scriptExt.indexOf('coffee') !== -1) {\n    options.exec = 'coffee';\n\n    // we need to get execArgs set before the script\n    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an\n    // execArg, while my-flag is a script arg\n    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);\n    options.execArgs = options.execArgs.concat(leadingArgs);\n    options.scriptPosition = 0;\n\n    if (options.execArgs.length > 0) {\n      // because this is the coffee executable, we need to combine the exec args\n      // into a single argument after the nodejs flag\n      options.execArgs = ['--nodejs', options.execArgs.join(' ')];\n    }\n  }\n\n  if (options.exec === 'coffee') {\n    // don't override user specified extension tracking\n    if (options.ext === undefined) {\n      if (extension) { extension += ','; }\n      extension += 'coffee,litcoffee';\n    }\n\n    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n    if (utils.isWindows) {\n      options.exec += '.cmd';\n    }\n  }\n\n  // allow users to make a mistake on the extension to monitor\n  // converts .js, pug => js,pug\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against\n  // the file system :(\n  extension = (extension.match(/[^,*\\s]+/g) || [])\n    .map(ext => ext.replace(/^\\./, ''))\n    .join(',');\n\n  options.ext = extension;\n\n  if (options.script) {\n    options.script = expandScript(options.script,\n      extension && ('.' + extension.split(',')[0]));\n  }\n\n  options.env = {};\n  // make sure it's an object (and since we don't have )\n  if (({}).toString.apply(nodemonOptions.env) === '[object Object]') {\n    options.env = utils.clone(nodemonOptions.env);\n  } else if (nodemonOptions.env !== undefined) {\n    throw new Error('nodemon env values must be an object: { PORT: 8000 }');\n  }\n\n  return options;\n}\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,UAAU,GAAGD,EAAE,CAACC,UAAU;AAChC,MAAMC,KAAK,GAAGH,OAAO,CAAC,UAAU,CAAC;AAEjCI,MAAM,CAACC,OAAO,GAAGC,IAAI;AACrBF,MAAM,CAACC,OAAO,CAACE,YAAY,GAAGA,YAAY;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAe,GAAG;EACzB;EACA;EACA;EACA,IAAI;IACF;IACA,IAAIC,GAAG,GAAGT,OAAO,CAACD,IAAI,CAACW,IAAI,CAACC,OAAO,CAACC,GAAG,EAAE,EAAE,cAAc,CAAC,CAAC;IAC3D,IAAIH,GAAG,CAACI,IAAI,KAAKC,SAAS,EAAE;MAC1B;MACA,OAAO;QAAER,IAAI,EAAE,IAAI;QAAES,MAAM,EAAEN,GAAG,CAACI;MAAK,CAAC;IACzC;IAEA,IAAIJ,GAAG,CAACO,OAAO,IAAIP,GAAG,CAACO,OAAO,CAACC,KAAK,EAAE;MACpC,OAAO;QAAEX,IAAI,EAAEG,GAAG,CAACO,OAAO,CAACC;MAAM,CAAC;IACpC;EACF,CAAC,CAAC,OAAOC,CAAC,EAAE,CAAE;EAEd,OAAO,IAAI;AACb;AAEA,SAASC,OAAO,CAACC,GAAG,EAAEC,GAAG,EAAE;EACzB,IAAIC,EAAE,GAAG,IAAIC,MAAM,CAAC,KAAK,GAAGC,MAAM,CAACC,IAAI,CAACL,GAAG,CAAC,CAACV,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,EAAE,GAAG,CAAC;EACpE,OAAOW,GAAG,CAACF,OAAO,CAACG,EAAE,EAAE,UAAUI,GAAG,EAAEC,CAAC,EAAE;IACvC,OAAOP,GAAG,CAACO,CAAC,CAAC,IAAID,GAAG,IAAI,EAAE;EAC5B,CAAC,CAAC;AACJ;AAEA,SAASnB,YAAY,CAACQ,MAAM,EAAEa,GAAG,EAAE;EACjC,IAAI,CAACA,GAAG,EAAE;IACRA,GAAG,GAAG,KAAK;EACb;EACA,IAAIb,MAAM,CAACc,OAAO,CAACD,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IAC9B,OAAOb,MAAM;EACf;EAEA,IAAIb,UAAU,CAACH,IAAI,CAAC+B,OAAO,CAACf,MAAM,CAAC,CAAC,EAAE;IACpC,OAAOA,MAAM;EACf;EAEA,IAAIb,UAAU,CAACH,IAAI,CAAC+B,OAAO,CAACf,MAAM,GAAGa,GAAG,CAAC,CAAC,EAAE;IAC1C,OAAOb,MAAM,GAAGa,GAAG;EACrB;EAEA,OAAOb,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,IAAI,CAACyB,cAAc,EAAEC,OAAO,EAAE;EACrC,IAAI,CAACA,OAAO,EAAE;IACZA,OAAO,GAAG,CAAC,CAAC;EACd;EAEA,IAAIC,OAAO,GAAG9B,KAAK,CAAC+B,KAAK,CAACH,cAAc,IAAI,CAAC,CAAC,CAAC;EAC/C,IAAIhB,MAAM;;EAEV;EACA,IAAI,CAACkB,OAAO,CAAClB,MAAM,IAAI,CAACkB,OAAO,CAACE,IAAI,IAAI,EAAE,EAAEC,MAAM,EAAE;IAClDrB,MAAM,GAAGR,YAAY,CAAC0B,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,EACnCF,OAAO,CAACL,GAAG,IAAK,GAAG,GAAG,CAACK,OAAO,CAACL,GAAG,IAAI,IAAI,EAAES,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAE,CAAC;;IAE7D;IACA,IAAItB,MAAM,KAAKkB,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,EAAE;MAC9BF,OAAO,CAAClB,MAAM,GAAGA,MAAM;MACvBkB,OAAO,CAACE,IAAI,CAACG,KAAK,EAAE;IACtB;EACF;;EAEA;EACA;EACA;EACA;EACA,IAAI,CAACL,OAAO,CAAC3B,IAAI,IAAI,CAAC2B,OAAO,CAAClB,MAAM,EAAE;IACpC,IAAIwB,KAAK,GAAG/B,eAAe,EAAE;IAC7B,IAAI+B,KAAK,KAAK,IAAI,EAAE;MAClB,IAAIA,KAAK,CAACjC,IAAI,EAAE;QACd2B,OAAO,CAAC3B,IAAI,GAAGiC,KAAK,CAACjC,IAAI;MAC3B;MACA,IAAI,CAAC2B,OAAO,CAAClB,MAAM,EAAE;QACnBkB,OAAO,CAAClB,MAAM,GAAGwB,KAAK,CAACxB,MAAM;MAC/B;MACA,IAAIyB,KAAK,CAACC,OAAO,CAACR,OAAO,CAACE,IAAI,CAAC,IAC7BF,OAAO,CAACS,cAAc,KAAK,IAAI,EAAE;QACjCT,OAAO,CAACS,cAAc,GAAGT,OAAO,CAACE,IAAI,CAACC,MAAM;MAC9C;IACF;EACF;;EAEA;EACArB,MAAM,GAAGhB,IAAI,CAAC4C,QAAQ,CAACV,OAAO,CAAClB,MAAM,IAAI,EAAE,CAAC;EAE5C,IAAI6B,SAAS,GAAG7C,IAAI,CAAC8C,OAAO,CAAC9B,MAAM,CAAC,CAAC+B,KAAK,CAAC,CAAC,CAAC;EAE7C,IAAIC,SAAS,GAAGd,OAAO,CAACL,GAAG;EAC3B,IAAImB,SAAS,KAAKjC,SAAS,EAAE;IAC3B,IAAIkC,IAAI,GAAGJ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK;IACpDG,SAAS,GAAIC,IAAI,IAAI,CAACJ,SAAS,GAAI,QAAQ,GAAGA,SAAS;IACvDG,SAAS,IAAI,OAAO,CAAC,CAAC;EACxB;;EAEA,IAAIE,WAAW,GAAG,CAAC,CAAChB,OAAO,CAAC3B,IAAI;;EAEhC;EACA;EACA;EACA,IAAI,CAAC2B,OAAO,CAAC3B,IAAI,IAAI0B,OAAO,CAACY,SAAS,CAAC,KAAK9B,SAAS,EAAE;IACrDmB,OAAO,CAAC3B,IAAI,GAAG0B,OAAO,CAACY,SAAS,CAAC;IACjCK,WAAW,GAAG,IAAI;EACpB;EAEAhB,OAAO,CAACiB,QAAQ,GAAGnB,cAAc,CAACmB,QAAQ,IAAI,EAAE;EAEhD,IAAIV,KAAK,CAACC,OAAO,CAACR,OAAO,CAAC3B,IAAI,CAAC,EAAE;IAC/B2B,OAAO,CAACiB,QAAQ,GAAGjB,OAAO,CAAC3B,IAAI;IAC/B2B,OAAO,CAAC3B,IAAI,GAAG2B,OAAO,CAACiB,QAAQ,CAACZ,KAAK,EAAE;EACzC;EAEA,IAAIL,OAAO,CAAC3B,IAAI,KAAKQ,SAAS,EAAE;IAC9BmB,OAAO,CAAC3B,IAAI,GAAG,MAAM;EACvB,CAAC,MAAM;IACL;IACA,IAAI6C,YAAY,GAAGhC,OAAO,CAACiC,IAAI,CAAC,IAAI,EAAE;MACpCC,QAAQ,EAAEpB,OAAO,CAAClB,MAAM;MACxBuC,GAAG,EAAE3C,OAAO,CAACC,GAAG;IAClB,CAAC,CAAC;IAEF,IAAI2C,OAAO,GAAGJ,YAAY,CAAClB,OAAO,CAAC3B,IAAI,CAAC;IACxC,IAAIiD,OAAO,KAAKtB,OAAO,CAAC3B,IAAI,IAC1B2B,OAAO,CAAC3B,IAAI,CAACuB,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7CI,OAAO,CAAClB,MAAM,GAAG,IAAI;IACvB;IACAkB,OAAO,CAAC3B,IAAI,GAAGiD,OAAO;IAEtB,IAAIC,WAAW,GAAGvB,OAAO,CAACiB,QAAQ,CAAC9B,GAAG,CAAC+B,YAAY,CAAC;IACpD,IAAIK,WAAW,CAAC9C,IAAI,CAAC,EAAE,CAAC,KAAKuB,OAAO,CAACiB,QAAQ,CAACxC,IAAI,CAAC,EAAE,CAAC,EAAE;MACtDuB,OAAO,CAACiB,QAAQ,GAAGM,WAAW;MAC9B,OAAOvB,OAAO,CAAClB,MAAM;IACvB;EACF;EAGA,IAAIkB,OAAO,CAAC3B,IAAI,KAAK,MAAM,IAAI2B,OAAO,CAACwB,QAAQ,IAAIxB,OAAO,CAACwB,QAAQ,CAACrB,MAAM,EAAE;IAC1EH,OAAO,CAACiB,QAAQ,GAAGjB,OAAO,CAACiB,QAAQ,CAACQ,MAAM,CAACzB,OAAO,CAACwB,QAAQ,CAAC;EAC9D;;EAEA;EACA,IAAI,CAACR,WAAW,IAAIhB,OAAO,CAAC3B,IAAI,KAAK,MAAM,IACzCsC,SAAS,CAACf,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;IACpCI,OAAO,CAAC3B,IAAI,GAAG,QAAQ;;IAEvB;IACA;IACA;IACA,IAAIqD,WAAW,GAAG,CAAC1B,OAAO,CAACE,IAAI,IAAI,EAAE,EAAEyB,MAAM,CAAC,CAAC,EAAE3B,OAAO,CAACS,cAAc,CAAC;IACxET,OAAO,CAACiB,QAAQ,GAAGjB,OAAO,CAACiB,QAAQ,CAACQ,MAAM,CAACC,WAAW,CAAC;IACvD1B,OAAO,CAACS,cAAc,GAAG,CAAC;IAE1B,IAAIT,OAAO,CAACiB,QAAQ,CAACd,MAAM,GAAG,CAAC,EAAE;MAC/B;MACA;MACAH,OAAO,CAACiB,QAAQ,GAAG,CAAC,UAAU,EAAEjB,OAAO,CAACiB,QAAQ,CAACxC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC7D;EACF;EAEA,IAAIuB,OAAO,CAAC3B,IAAI,KAAK,QAAQ,EAAE;IAC7B;IACA,IAAI2B,OAAO,CAACL,GAAG,KAAKd,SAAS,EAAE;MAC7B,IAAIiC,SAAS,EAAE;QAAEA,SAAS,IAAI,GAAG;MAAE;MACnCA,SAAS,IAAI,kBAAkB;IACjC;;IAEA;IACA,IAAI5C,KAAK,CAAC0D,SAAS,EAAE;MACnB5B,OAAO,CAAC3B,IAAI,IAAI,MAAM;IACxB;EACF;;EAEA;EACA;EACA;EACA;EACA;EACAyC,SAAS,GAAG,CAACA,SAAS,CAACe,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,EAC5C1C,GAAG,CAACQ,GAAG,IAAIA,GAAG,CAACT,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAClCT,IAAI,CAAC,GAAG,CAAC;EAEZuB,OAAO,CAACL,GAAG,GAAGmB,SAAS;EAEvB,IAAId,OAAO,CAAClB,MAAM,EAAE;IAClBkB,OAAO,CAAClB,MAAM,GAAGR,YAAY,CAAC0B,OAAO,CAAClB,MAAM,EAC1CgC,SAAS,IAAK,GAAG,GAAGA,SAAS,CAACV,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAE,CAAC;EACjD;EAEAJ,OAAO,CAAC8B,GAAG,GAAG,CAAC,CAAC;EAChB;EACA,IAAK,CAAC,CAAC,CAAEC,QAAQ,CAACC,KAAK,CAAClC,cAAc,CAACgC,GAAG,CAAC,KAAK,iBAAiB,EAAE;IACjE9B,OAAO,CAAC8B,GAAG,GAAG5D,KAAK,CAAC+B,KAAK,CAACH,cAAc,CAACgC,GAAG,CAAC;EAC/C,CAAC,MAAM,IAAIhC,cAAc,CAACgC,GAAG,KAAKjD,SAAS,EAAE;IAC3C,MAAM,IAAIoD,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,OAAOjC,OAAO;AAChB"},"metadata":{},"sourceType":"script"}